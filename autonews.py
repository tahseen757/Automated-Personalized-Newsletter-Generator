# -*- coding: utf-8 -*-
"""Autonews.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TaNmMEqWvz41g98AEb_WtYHhQoYnIB8M
"""

import os
import datetime
import requests
import torch
import pandas as pd
import smtplib
import logging
import json
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from googleapiclient.discovery import build
from google.oauth2 import service_account
from transformers import AutoTokenizer, AutoModelForSeq2SeqLM
from sentence_transformers import SentenceTransformer, util
from tenacity import retry, stop_after_attempt, wait_fixed  # pip install tenacity if needed locally

# Setup logging
logging.basicConfig(filename='newsletter_log.txt', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Load from environment variables (set in GitHub Secrets)
NEWS_API_KEY = os.environ.get('NEWS_API_KEY')
SENDER_EMAIL = os.environ.get('SENDER_EMAIL')
SENDER_PASSWORD = os.environ.get('SENDER_PASSWORD')
service_account_info = json.loads(os.environ.get('SERVICE_ACCOUNT_JSON'))  # Full JSON content as string
SCOPES = ['https://www.googleapis.com/auth/calendar.readonly']

device = 0 if torch.cuda.is_available() else -1

class DataLoader:
    def __init__(self):
        self.users_df = pd.DataFrame([
            {'id': 1, 'name': 'Alex Chen', 'email': 'jadewarrior679@gmail.com', 'interests': ['Artificial Intelligence', 'Python', 'Cloud Computing'], 'location': 'us'},
            {'id': 2, 'name': 'Sarah Miller', 'email': 'groupasshomies@gmail.com', 'interests': ['Leadership', 'Productivity', 'Agile Methodology'], 'location': 'us'}
        ])
        self.service = self.authenticate_google()

    def authenticate_google(self):
        try:
            credentials = service_account.Credentials.from_service_account_info(service_account_info, scopes=SCOPES)
            logging.info('Google auth successful')
            return build('calendar', 'v3', credentials=credentials)
        except Exception as e:
            logging.error(f'Google auth failed: {e}')
            return None

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
    def fetch_calendar_events(self):
        if not self.service:
            return []
        now = datetime.datetime.now(datetime.timezone.utc).isoformat()
        try:
            events_result = self.service.events().list(calendarId='primary', timeMin=now, maxResults=3, singleEvents=True, orderBy='startTime').execute()
            logging.info('Calendar events fetched')
            return [{'summary': e.get('summary', 'No Title'), 'start': e['start'].get('dateTime', e['start'].get('date'))} for e in events_result.get('items', [])]
        except Exception as e:
            logging.error(f'Calendar fetch failed: {e}')
            return [{'summary': 'No events (access issue)', 'start': '--'}]

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
    def fetch_global_news(self):
        base_url = 'https://newsapi.org/v2/top-headlines'
        params = {'apiKey': NEWS_API_KEY, 'country': 'us', 'category': 'technology', 'pageSize': 10}
        try:
            res = requests.get(base_url, params=params).json()
            articles = [{'title': a['title'], 'description': a['description']} for a in res.get('articles', []) if a.get('description')]
            logging.info('News fetched')
            return articles
        except Exception as e:
            logging.error(f'News fetch failed: {e}')
            return []

class NewsletterEngine:
    def __init__(self):
        self.matcher = SentenceTransformer('all-MiniLM-L6-v2')
        model_name = 'sshleifer/distilbart-cnn-12-6'
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModelForSeq2SeqLM.from_pretrained(model_name).to('cuda' if device == 0 else 'cpu')

    def process_content(self, user_interests, news_items):
        if not news_items:
            return []
        interest_text = ' '.join(user_interests)
        interest_emb = self.matcher.encode(interest_text, convert_to_tensor=True)
        news_embs = self.matcher.encode([n['description'] for n in news_items], convert_to_tensor=True)
        scores = util.cos_sim(interest_emb, news_embs)[0]
        for i, score in enumerate(scores):
            news_items[i]['score'] = score.item()
        top_items = sorted(news_items, key=lambda x: x['score'], reverse=True)[:3]
        for item in top_items:
            inputs = self.tokenizer(item['description'], return_tensors='pt', truncation=True).to(self.model.device)
            summary_ids = self.model.generate(inputs['input_ids'], max_length=50)
            item['summary'] = self.tokenizer.decode(summary_ids[0], skip_special_tokens=True)
        return top_items

class EmailDispatcher:
    @staticmethod
    def send_email(recipient_email, recipient_name, content):
        msg = MIMEMultipart()
        msg['From'] = SENDER_EMAIL
        msg['To'] = recipient_email
        msg['Subject'] = f'üì¢ Daily Briefing - {datetime.date.today().strftime("%B %d, %Y")}'

        # HTML for better formatting
        html = f"""
        <html><body>
        <h2>Hello {recipient_name},</h2>
        <p>Your personalized daily briefing:</p>
        {content.replace('\n', '<br>')}
        </body></html>
        """
        msg.attach(MIMEText(html, 'html'))

        try:
            server = smtplib.SMTP('smtp.gmail.com', 587)
            server.starttls()
            server.login(SENDER_EMAIL, SENDER_PASSWORD)
            server.send_message(msg)
            server.quit()
            logging.info(f'Sent to: {recipient_email}')
        except Exception as e:
            logging.error(f'Failed to send to {recipient_email}: {e}')

def run_automation():
    logging.info('Starting daily run')
    loader = DataLoader()
    engine = NewsletterEngine()
    dispatcher = EmailDispatcher()

    for _, user in loader.users_df.iterrows():
        logging.info(f'Processing user: {user["name"]}')
        events = loader.fetch_calendar_events()
        news = loader.fetch_global_news()
        processed_news = engine.process_content(user['interests'], news)

        content = 'üìÖ CALENDAR EVENTS:<br>' + ('<br>'.join([f'‚Ä¢ {e["summary"]} at {e["start"]}' for e in events]) if events else 'No upcoming events') + '<br><br>'
        content += 'üåç PERSONALIZED NEWS:<br>'
        for i, n in enumerate(processed_news):
            content += f'{i+1}. <b>{n["title"]}</b><br>   Summary: {n["summary"]}<br><br>'

        dispatcher.send_email(user['email'], user['name'], content)
    logging.info('Daily run complete')

if __name__ == '__main__':
    run_automation()